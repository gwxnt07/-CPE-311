# -*- coding: utf-8 -*-
"""Esperat - Hands_on_Activity_2_1_Dynamic_Programming_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/162z-K9tNiSCIdHzepMugeD3lv12T4jHE

# Hands-on Activity 2.1 : Dynamic Programming

#### Objective(s):

This activity aims to demonstrate how to use dynamic programming to solve problems.

#### Intended Learning Outcomes (ILOs):
* Differentiate recursion method from dynamic programming to solve problems.
* Demonstrate how to  solve real-world problems using dynamic programming

#### Resources:
* Jupyter Notebook

#### Procedures:

1. Create a code that demonstrate how to use recursion method to solve problem
"""

def knapsack_recursive(capacity, weights, values, n):
    if n == 0 or capacity == 0:
        return 0

    if weights[n - 1] > capacity:
        return knapsack_recursive(capacity, weights, values, n - 1)
    else:
        return max(values[n - 1] + knapsack_recursive(capacity - weights[n - 1], weights, values, n - 1),
                   knapsack_recursive(capacity, weights, values, n - 1))

# Example usage:
values = [60, 100, 120]
weights = [10, 20, 30]
capacity = 50
n = len(values)

max_value = knapsack_recursive(capacity, weights, values, n)
print("Maximum value that can be obtained with recursion:", max_value)

"""2. Create a program codes that demonstrate how to use dynamic programming to solve the same problem"""

def knapsack_dp(capacity, weights, values, n):
    dp_table = [[0] * (capacity + 1) for _ in range(n + 1)]
    for i in range(1, n + 1):
        for w in range(1, capacity + 1):
            if weights[i - 1] <= w:
                dp_table[i][w] = max(values[i - 1] + dp_table[i - 1][w - weights[i - 1]],
                                     dp_table[i - 1][w])
            else:
                dp_table[i][w] = dp_table[i - 1][w]

    return dp_table[n][capacity]

values = [60, 100, 120]
weights = [10, 20, 30]
capacity = 50
n = len(values)

max_value_dp = knapsack_dp(capacity, weights, values, n)
print("Maximum value that can be obtained with dynamic programming:", max_value_dp)

"""##### Question:
Explain the difference of using the recursion from dynamic programming using the given sample codes to solve the same problem

Type your answer here:

3. Create a sample program codes to simulate bottom-up dynamic programming
"""

import numpy as np
import matplotlib.pyplot as plt

def random_walk_bottom_up(num_steps, step_size):
    x_memo = {}
    y_memo = {}

    for i in range(num_steps + 1):
        x_memo[(0, i)] = [0]  # Initialize x position for each step
        y_memo[(0, i)] = [0]  # Initialize y position for each step

    for i in range(1, num_steps + 1):
        for j in range(1, i + 1):
            for dx, dy in [(0, step_size), (0, -step_size), (step_size, 0), (-step_size, 0)]:
                new_x = x_memo[(dx, i - 1)][-1] + dx
                new_y = y_memo[(0, i - 1)][-1] + dy  # Corrected initialization of y position
                if (new_x, i) not in x_memo:
                    x_memo[(new_x, i)] = x_memo[(dx, i - 1)] + [new_x]
                    y_memo[(new_y, i)] = y_memo[(0, i - 1)] + [new_y]  # Corrected initialization of y position

    return x_memo[(new_x, num_steps)], y_memo[(new_y, num_steps)]

num_steps = 100
step_size = 0.1  # Decreased step size

x_trajectory, y_trajectory = random_walk_bottom_up(num_steps, step_size)

plt.plot(x_trajectory, y_trajectory)
plt.xlabel("X")
plt.ylabel("Y")
plt.title("2D Random Walk (Bottom-Up DP)")
plt.show()

"""4. Create a sample program codes that simulate tops-down dynamic programming


"""

import numpy as np
import matplotlib.pyplot as plt

def random_walk_memo(num_steps, step_size, x=0, y=0, x_memo=None, y_memo=None):
    if x_memo is None:
        x_memo = {}
    if y_memo is None:
        y_memo = {}

    if num_steps == 0:
        return [x], [y]

    if (x, num_steps) in x_memo and (y, num_steps) in y_memo:
        return x_memo[(x, num_steps)], y_memo[(y, num_steps)]

    direction = np.random.choice(["up", "down", "left", "right"])

    if direction == "up":
        y += step_size
    elif direction == "down":
        y -= step_size
    elif direction == "left":
        x -= step_size
    else:
        x += step_size

    x_trajectory, y_trajectory = random_walk_memo(num_steps - 1, step_size, x, y, x_memo, y_memo)

    x_trajectory.append(x)
    y_trajectory.append(y)

    x_memo[(x, num_steps)] = x_trajectory
    y_memo[(y, num_steps)] = y_trajectory

    return x_trajectory, y_trajectory

num_steps = 100
step_size = 0.1  # Decreased step size

x_trajectory, y_trajectory = random_walk_memo(num_steps, step_size)

plt.plot(x_trajectory, y_trajectory)
plt.xlabel("X")
plt.ylabel("Y")
plt.title("2D Random Walk (Top-Down DP - Memoization)")
plt.show()

"""#### Question:
 Explain the difference between bottom-up from top-down dynamic programming using the given sample codes

Type your answer here:

0/1 Knapsack Problem

* Analyze three different techniques to solve knapsacks problem
1. Recursion
2. Dynamic Programming
3. Memoization
"""

#sample code for knapsack problem using recursion
def rec_knapSack(w, wt, val, n):

  #base case
  #defined as nth item is empty;
  #or the capacity w is 0
  if n == 0 or w == 0:
    return 0

  #if weight of the nth item is more than
  #the capacity W, then this item cannot be included
  #as part of the optimal solution
  if(wt[n-1] > w):
    return rec_knapSack(w, wt, val, n-1)

  #return the maximum of the two cases:
  # (1) include the nth item
  # (2) don't include the nth item
  else:
    return max(
        val[n-1] + rec_knapSack(
            w-wt[n-1], wt, val, n-1),
            rec_knapSack(w, wt, val, n-1)
    )

#To test:
val = [60, 100, 120] #values for the items
wt = [10, 20, 30] #weight of the items
w = 50 #knapsack weight capacity
n = len(val) #number of items

rec_knapSack(w, wt, val, n)

#Dynamic Programming for the Knapsack Problem
def DP_knapSack(w, wt, val, n):
  #create the table
  table = [[0 for x in range(w+1)] for x in range (n+1)]

  #populate the table in a bottom-up approach
  for i in range(n+1):
    for w in range(w+1):
      if i == 0 or w == 0:
        table[i][w] = 0
      elif wt[i-1] <= w:
        table[i][w] = max(val[i-1] + table[i-1][w-wt[i-1]],
                          table[i-1][w])
  return table[n][w]

#To test:
val = [60, 100, 120]
wt = [10, 20, 30]
w = 50
n = len(val)

DP_knapSack(w, wt, val, n)

#Sample for top-down DP approach (memoization)
#initialize the list of items
val = [60, 100, 120]
wt = [10, 20, 30]
w = 50
n = len(val)

#initialize the container for the values that have to be stored
#values are initialized to -1
calc =[[-1 for i in range(w+1)] for j in range(n+1)]


def mem_knapSack(wt, val, w, n):
  #base conditions
  if n == 0 or w == 0:
    return 0
  if calc[n][w] != -1:
    return calc[n][w]

  #compute for the other cases
  if wt[n-1] <= w:
    calc[n][w] = max(val[n-1] + mem_knapSack(wt, val, w-wt[n-1], n-1),
                     mem_knapSack(wt, val, w, n-1))
    return calc[n][w]
  elif wt[n-1] > w:
    calc[n][w] = mem_knapSack(wt, val, w, n-1)
    return calc[n][w]

mem_knapSack(wt, val, w, n)

"""**Code Analysis**

The code provided solves the 0/1 Knapsack Problem using three different approaches: recursion, dynamic programming (bottom-up approach), and memoization (top-down approach). Recursion is used to explore all possible combinations of items, but this approach is inefficient for large inputs due to its exponential time complexity. Dynamic programming in a bottom-up manner iteratively fills a table with solutions to subproblems, offering a time complexity of O(n * w), where n is the number of items and w is the capacity of the knapsack. This approach avoids redundant calculations and is therefore more efficient than recursion. Memoization, a top-down dynamic programming approach, optimizes recursion by storing previously computed results. This reduces the number of recursive calls and therefore the amount of redundant computation, but it comes with the overhead of function calls and memory usage. Both dynamic programming approaches offer efficient solutions to the 0/1 Knapsack Problem, but the choice between bottom-up and top-down methods depends on factors such as space constraints and the nature of the problem.

## Seatwork 2.1

Task 1: Modify the three techniques to include additional criterion in the knapsack problems
"""

# Type your code here

# Recursion
def rec_knapSack_modified(w, wt, val, n, criterion):
    if n == 0 or w == 0:
        return 0
    if criterion == "additional":
        pass

    if wt[n-1] > w:
        return rec_knapSack_modified(w, wt, val, n-1, criterion)
    else:
        return max(
            val[n-1] + rec_knapSack_modified(w-wt[n-1], wt, val, n-1, criterion),
            rec_knapSack_modified(w, wt, val, n-1, criterion)
        )

# Dynamic Programming
def DP_knapSack_modified(w, wt, val, n, criterion):
    table = [[0 for x in range(w+1)] for x in range(n+1)]
    for i in range(n+1):
        for w in range(w+1):
            if i == 0 or w == 0:
                table[i][w] = 0
            elif wt[i-1] <= w:
                if criterion == "additional":
                    pass
                table[i][w] = max(val[i-1] + table[i-1][w-wt[i-1]], table[i-1][w])
    return table[n][w]

# Memoization
def mem_knapSack_modified(wt, val, w, n, criterion):
    if n == 0 or w == 0:
        return 0
    if calc[n][w] != -1:
        return calc[n][w]

    if wt[n-1] <= w:
        if criterion == "additional":
            pass
        calc[n][w] = max(val[n-1] + mem_knapSack_modified(wt, val, w-wt[n-1], n-1, criterion),
                         mem_knapSack_modified(wt, val, w, n-1, criterion))
        return calc[n][w]
    elif wt[n-1] > w:
        calc[n][w] = mem_knapSack_modified(wt, val, w, n-1, criterion)
        return calc[n][w]

"""Fibonacci Numbers

Task 2: Create a sample program that find the nth number of Fibonacci Series using Dynamic Programming
"""

def fibonacci(n):
    fib = [0, 1]
    for i in range(2, n + 1):
        fib.append(fib[i - 1] + fib[i - 2])
    return fib

# To print all Fibonacci numbers up to n:
n = 10
fibonacci_sequence = fibonacci(n)
print(f"Fibonacci Sequence up to {n} terms:")
for term in fibonacci_sequence:
    print(term, end=" ")

"""## Supplementary Problem (HOA 2.1 Submission):
* Choose a real-life problem
* Use recursion and dynamic programming to solve the problem

The real-world problem that I choose was a list of Interns with their corresponding salary and hours required to receive the salary.


The idea that I used knapsacks problem is the interns that has the least required hours and high salary.

In conclusion, the results of the greedy and brute force algorithm solves the problem since most of the results has the least hours and high salary.
"""

class Interns(object):
    def __init__(self, n, s, h):
        self.name = n
        self.salary = s
        self.hours = h

    def getName(self):
        return self.name

    def getSalary(self):
        return self.salary

    def getHours(self):
        return self.hours

    def density(self):
        return self.salary/self.hours

    def __str__(self):
        return self.name + ' <' + str(self.salary) + ', ' + str(self.hours) + '>'

def buildMenu(names, salary, hours):
    menu = []
    for i in range(len(salary)):
        menu.append(Interns(names[i], salary[i],hours[i]))
    return menu

def maxVal(toConsider, avail):
    """Assumes toConsider a list of items, avail a weight
       Returns a tuple of the total value of a solution to the
         0/1 knapsack problem and the items of that solution"""
    if toConsider == [] or avail == 0:
        result = (0, ())
    elif toConsider[0].getSalary() > avail:
        #Explore right branch only
        result = maxVal(toConsider[1:], avail)
    else:
        nextItem = toConsider[0]
        #Explore left branch
        withVal, withToTake = maxVal(toConsider[1:],
                                     avail - nextItem.getSalary())
        withVal += nextItem.getSalary()
        #Explore right branch
        withoutVal, withoutToTake = maxVal(toConsider[1:], avail)
        #Choose better branch
        if withVal > withoutVal:
            result = (withVal, withToTake + (nextItem,))
        else:
            result = (withoutVal, withoutToTake)
    return result

def testMaxVal(foods, maxUnits, printItems = True):
    print('Use search tree to allocate', maxUnits,
          'salaries')
    val, taken = maxVal(foods, maxUnits)
    print('Total salary of Interns taken =', val)
    if printItems:
        for item in taken:
            print('   ', item)

# Data
InternsName = ['Interns1', 'Interns2','Interns3','Interns4','Interns5','Interns6','Interns7','Interns8','Interns9','Interns10']
hours = [3,1,8,7,5,9,8,1,5,2]
salaries = [500,800,300,900,400,900,200,400,600,700]

Interns = buildMenu(InternsName, salaries, hours)

testMaxVal(Interns, 1000)

class Interns(object):
    def __init__(self, n, s, h):
        self.name = n
        self.salary = s
        self.hours = h

    def getName(self):
        return self.name

    def getSalary(self):
        return self.salary

    def getHours(self):
        return self.hours

    def density(self):
        return self.salary/self.hours

    def __str__(self):
        return self.name + ' <' + str(self.salary) + ', ' + str(self.hours) + '>'

def buildMenu(names, salary, hours):
    menu = []
    for i in range(len(salary)):
        menu.append(Interns(names[i], salary[i],hours[i]))
    return menu

def greedy(items, maxSalary, keyFunction):
    itemsCopy = sorted(items, key = keyFunction,
                       reverse = True)
    result = []
    totalValue, totalSalary = 0.0, 0.0
    for i in range(len(itemsCopy)):
        if (totalSalary+itemsCopy[i].getSalary()) <= maxSalary:
            result.append(itemsCopy[i])
            totalSalary += itemsCopy[i].getSalary()
            totalValue += itemsCopy[i].getSalary()
    return (result, totalValue)

def testGreedy(items, constraint, keyFunction):
    taken, val = greedy(items, constraint, keyFunction)
    print('Total value of items taken =', val)
    for item in taken:
        print('   ', item)

def testGreedys(foods, maxUnits):
    print('Use greedy by hours to allocate', maxUnits,          'hours')
    testGreedy(foods, maxUnits, Interns.getSalary())
    print('\nUse greedy by salary to allocate', maxUnits,          'hours')
    testGreedy(foods, maxUnits, lambda x: 1/Interns.density(x))
    print('\nUse greedy by hourly rate to allocate', maxUnits,          'hours')
    testGreedy(foods, maxUnits, Interns.density())

InternsName = ['Interns1', 'Interns2','Interns3','Interns4','Interns5','Interns','Interns7','Interns8','Interns9','Interns10']
hours = [3,1,8,7,5,9,8,1,5,2]
salaries = [500,800,300,900,400,900,200,400,600,700]

Interns = buildMenu(InternsName, salaries, hours)
testGreedys(InternsName, 1000)

#type your code here for recursion programming solution
def maxVal_dp(toConsider, avail):
    """Assumes toConsider a list of items, avail a weight
       Returns a tuple of the total value of a solution to the
         0/1 knapsack problem and the items of that solution"""
    memo = {}

    def dp_helper(i, avail):
        if (i, avail) in memo:
            return memo[(i, avail)]

        if i == len(toConsider) or avail == 0:
            result = (0, ())
        elif toConsider[i].getSalary() > avail:
            result = dp_helper(i + 1, avail)
        else:
            nextItem = toConsider[i]
            withVal, withToTake = dp_helper(i + 1, avail - nextItem.getSalary())
            withVal += nextItem.getSalary()
            withoutVal, withoutToTake = dp_helper(i + 1, avail)
            if withVal > withoutVal:
                result = (withVal, withToTake + (nextItem,))
            else:
                result = (withoutVal, withoutToTake)

        memo[(i, avail)] = result
        return result

    return dp_helper(0, avail)


def testMaxVal_dp(foods, maxUnits, printItems=True):
    print('Use dynamic programming to allocate', maxUnits, 'salaries')
    val, taken = maxVal_dp(foods, maxUnits)
    print('Total salary of Interns taken =', val)
    if printItems:
        for item in taken:
            print(' ', item)


# Test dynamic programming approach
testMaxVal_dp(Interns, 1000)

#type your code here for dynamic programming solution
def maxVal_recursive(toConsider, avail):
    """Assumes toConsider a list of items, avail a weight
       Returns a tuple of the total value of a solution to the
         0/1 knapsack problem and the items of that solution"""
    if toConsider == [] or avail == 0:
        result = (0, ())
    elif toConsider[0].getSalary() > avail:
        result = maxVal_recursive(toConsider[1:], avail)
    else:
        nextItem = toConsider[0]
        withVal, withToTake = maxVal_recursive(toConsider[1:], avail - nextItem.getSalary())
        withVal += nextItem.getSalary()
        withoutVal, withoutToTake = maxVal_recursive(toConsider[1:], avail)
        if withVal > withoutVal:
            result = (withVal, withToTake + (nextItem,))
        else:
            result = (withoutVal, withoutToTake)
    return result


def testMaxVal_recursive(foods, maxUnits, printItems=True):
    print('Use recursion to allocate', maxUnits, 'salaries')
    val, taken = maxVal_recursive(foods, maxUnits)
    print('Total salary of Interns taken =', val)
    if printItems:
        for item in taken:
            print('   ', item)


# Test recursion approach
testMaxVal_recursive(Interns, 1000)

"""#### Conclusion

In this activity, The dynamic programming often involves breaking down a problem into smaller subproblems and solving each subproblem recursively. However, to avoid redundant calculations, the results of these subproblems are stored and reused as needed. This approach effectively reduces the time complexity of the overall solution. To sum up, the 0dynamic programming combines the benefits of recursion breaking down a problem into smaller, more manageable subproblems with the efficiency of memoization storing and reusing previously computed results to achieve optimal solutions to complex problems.
"""