# -*- coding: utf-8 -*-
"""Esperat, Hands-on Activity 1.3 - Transportation using Graphs.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JnyTGikptDOgOKn-LQ7LW2tvXgTYfxF9

# Hands-on Activity 1.3 | Transportation using Graphs

#### Objective(s):

This activity aims to demonstrate how to solve transportation related problem using Graphs

#### Intended Learning Outcomes (ILOs):
* Demonstrate how to compute the shortest path from source to destination using graphs
* Apply DFS and BFS to compute the shortest path

#### Resources:
* Jupyter Notebook

#### Procedures:

1. Create a Node class
"""

class Node(object):
    def __init__(self, name):
        """Assumes name is a string"""
        self.name = name
    def getName(self):
        return self.name
    def __str__(self):
        return self.name

"""2. Create an Edge class"""

class Edge(object):
    def __init__(self, src, dest):
        """Assumes src and dest are nodes"""
        self.src = src
        self.dest = dest
    def getSource(self):
        return self.src
    def getDestination(self):
        return self.dest
    def __str__(self):
        return self.src.getName() + '->' + self.dest.getName()

"""3. Create Digraph class that add nodes and edges"""

class Digraph(object):
    """edges is a dict mapping each node to a list of
    its children"""
    def __init__(self):
        self.edges = {}
    def addNode(self, node):
        if node in self.edges:
            raise ValueError('Duplicate node')
        else:
            self.edges[node] = []
    def addEdge(self, edge):
        src = edge.getSource()
        dest = edge.getDestination()
        if not (src in self.edges and dest in self.edges):
            raise ValueError('Node not in graph')
        self.edges[src].append(dest)
    def childrenOf(self, node):
        return self.edges[node]
    def hasNode(self, node):
        return node in self.edges
    def getNode(self, name):
        for n in self.edges:
            if n.getName() == name:
                return n
        raise NameError(name)
    def __str__(self):
        result = ''
        for src in self.edges:
            for dest in self.edges[src]:
                result = result + src.getName() + '->'\
                         + dest.getName() + '\n'
        return result[:-1] #omit final newline

"""4. Create a Graph class from Digraph class that deifnes the destination and Source"""

class Graph(Digraph):
    def addEdge(self, edge):
        Digraph.addEdge(self, edge)
        rev = Edge(edge.getDestination(), edge.getSource())
        Digraph.addEdge(self, rev)

"""5. Create a buildCityGraph method to add nodes (City) and edges   (source to destination)"""

def buildCityGraph(graphType):
    g = graphType()
    for name in ('Boston', 'Providence', 'New York', 'Chicago', 'Denver', 'Phoenix', 'Los Angeles'):
        #Create 7 nodes
        g.addNode(Node(name))
    g.addEdge(Edge(g.getNode('Boston'), g.getNode('Providence')))
    g.addEdge(Edge(g.getNode('Boston'), g.getNode('New York')))
    g.addEdge(Edge(g.getNode('Providence'), g.getNode('Boston')))
    g.addEdge(Edge(g.getNode('Providence'), g.getNode('New York')))
    g.addEdge(Edge(g.getNode('New York'), g.getNode('Chicago')))
    g.addEdge(Edge(g.getNode('Chicago'), g.getNode('Denver')))
    g.addEdge(Edge(g.getNode('Denver'), g.getNode('Phoenix')))
    g.addEdge(Edge(g.getNode('Denver'), g.getNode('New York')))
    g.addEdge(Edge(g.getNode('Los Angeles'), g.getNode('Boston')))
    return g

def printPath(path):
    """Assumes path is a list of nodes"""
    result = ''
    for i in range(len(path)):
        result = result + str(path[i])
        if i != len(path) - 1:
            result = result + '->'
    return result

"""6. Create a method to define DFS technique"""

def DFS(graph, start, end, path, shortest, toPrint = False):
    """Assumes graph is a Digraph; start and end are nodes;
          path and shortest are lists of nodes
       Returns a shortest path from start to end in graph"""
    path = path + [start]
    if toPrint:
        print('Current DFS path:', printPath(path))
    if start == end:
        return path
    for node in graph.childrenOf(start):
        if node not in path: #avoid cycles
            if shortest == None or len(path) < len(shortest):
                newPath = DFS(graph, node, end, path, shortest,
                              toPrint)
                if newPath != None:
                    shortest = newPath
        elif toPrint:
            print('Already visited', node)
    return shortest

"""7. Define a shortestPath method to return the shortest path from source to destination using DFS"""

def shortestPath(graph, start, end, toPrint = False):
    """Assumes graph is a Digraph; start and end are nodes
       Returns a shortest path from start to end in graph"""
    return DFS(graph, start, end, [], None, toPrint)

"""8. Create a method to test the shortest path method"""

def testSP(source, destination):
    g = buildCityGraph(Digraph)
    sp = shortestPath(g, g.getNode(source), g.getNode(destination),
                      toPrint = True)
    if sp != None:
        print('Shortest path from', source, 'to',
              destination, 'is', printPath(sp))
    else:
        print('There is no path from', source, 'to', destination)

"""9. Execute the testSP method"""

testSP('Boston', 'Phoenix')

"""##### Question:
    
Describe the DFS method to compute for the shortest path using the given sample codes

#type your answer here
"""

def DFS(graph, start, end, path, shortest, toPrint=False):

"""1. **Parameters**:
   - graph: The graph on which DFS is performed.
   - start: The starting node for DFS.
   - end: The destination node for DFS.
   - path: A list representing the current path being explored.
   - shortest: A list representing the shortest path found so far.
   - toPrint: A boolean indicating whether to print the current DFS path.

3. **DFS Process**:
   - The function appends the start node to the path.
   - If start is equal to end, it means the destination is reached, so it returns the path.
   - For each child node of the current start node, DFS is recursively called if the child is not already in the path to avoid cycles.
   - If shortest is None or the length of the current path is shorter than the length of shortest, it updates shortest with the new path.

3. **Returning the Shortest Path**:
   - After DFS exploration, the function returns the shortest path found.

4. **Printing**:
   - If toPrint is True, the function prints the current DFS path and any nodes that have already been visited.

DFS method explores paths in a depth-first manner, backtracking when necessary, and keeps track of the shortest path found so far. This approach ensures that the shortest path between the given start and end nodes is computed.

10. Create a method to define BFS technique
"""

def BFS(graph, start, end, toPrint = False):
    """Assumes graph is a Digraph; start and end are nodes
       Returns a shortest path from start to end in graph"""
    initPath = [start]
    pathQueue = [initPath]
    while len(pathQueue) != 0:
        #Get and remove oldest element in pathQueue
        tmpPath = pathQueue.pop(0)
        if toPrint:
            print('Current BFS path:', printPath(tmpPath))
        lastNode = tmpPath[-1]
        if lastNode == end:
            return tmpPath
        for nextNode in graph.childrenOf(lastNode):
            if nextNode not in tmpPath:
                newPath = tmpPath + [nextNode]
                pathQueue.append(newPath)
    return None

"""11. Define a shortestPath method to return the shortest path from source to destination using DFS"""

def shortestPath(graph, start, end, toPrint = False):
    """Assumes graph is a Digraph; start and end are nodes
       Returns a shortest path from start to end in graph"""
    return BFS(graph, start, end, toPrint)

"""12. Execute the testSP method"""

testSP('Boston', 'Phoenix')

"""#### Question:
    
Describe the BFS method to compute for the shortest path using the given sample codestion:
    
"""

def BFS(graph, start, end):

"""1. **Parameters**:
   - graph: The graph on which BFS is performed.
   - start: The starting node for BFS.
   - end: The destination node for BFS.

2. **BFS Process**:
   - BFS starts by initializing a queue and enqueuing the start node.
   - It also initializes a path dictionary to keep track of the paths from the start node to all other nodes in the graph.
   - While the queue is not empty, BFS dequeues a node (current_node) from the queue.
   - For each child node (next_node) of the current_node, BFS checks if next_node is not already visited (not in the path dictionary).
   - If next_node is not visited, BFS updates the path dictionary to include the path from the start node to next_node through current_node.
   - BFS enqueues next_node to continue exploring its neighbors.
   - This process continues until all nodes reachable from the start node are visited.
   - Once BFS has visited all reachable nodes, it constructs the shortest path from start to end using the path dictionary.

3. **Returning the Shortest Path**:
   - BFS returns the shortest path from start to end by tracing back from end using the path dictionary.

4. **Printing**:
   - During BFS execution, the function prints the current BFS path, showing the nodes being explored in sequence.

BFS explores nodes in layers, starting from the start node and moving outward, ensuring that shorter paths are explored before longer ones. This approach guarantees that the shortest path between the start and end nodes is found.

#### Supplementary Activitiy
* Use a specific location or city to solve transportation using graph
* Use DFS and BFS methods to compute the shortest path
* Display the shortest path from source to destination using DFS and BFS
* Differentiate the performance of DFS from BFS
"""

from collections import defaultdict

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)

    def add_edge(self, u, v):
        self.graph[u].append(v)

    def get_neighbors(self, u):
        return self.graph[u]

# Define the road connections in Cityville
cityville_graph = Graph()
cityville_graph.add_edge("Home", "School")
cityville_graph.add_edge("Home", "Park")
cityville_graph.add_edge("School", "Library")
cityville_graph.add_edge("School", "Hospital")
cityville_graph.add_edge("Library", "Gym")
cityville_graph.add_edge("Hospital", "Market")
cityville_graph.add_edge("Market", "Park")

def dfs_shortest_path(graph, start, end, path=None):
    if path is None:
        path = []
    path = path + [start]
    if start == end:
        return path
    shortest = None
    for neighbor in graph.get_neighbors(start):
        if neighbor not in path:
            new_path = dfs_shortest_path(graph, neighbor, end, path)
            if new_path:
                if not shortest or len(new_path) < len(shortest):
                    shortest = new_path
    return shortest

def bfs_shortest_path(graph, start, end):
    queue = [(start, [start])]
    while queue:
        (vertex, path) = queue.pop(0)
        for neighbor in graph.get_neighbors(vertex):
            if neighbor not in path:
                if neighbor == end:
                    return path + [neighbor]
                else:
                    queue.append((neighbor, path + [neighbor]))

# Find the shortest path from Home to Park using DFS
dfs_path = dfs_shortest_path(cityville_graph, "Home", "Park")
print("Shortest path from Home to Park (DFS):", dfs_path)

# Find the shortest path from Home to Park using BFS
bfs_path = bfs_shortest_path(cityville_graph, "Home", "Park")
print("Shortest path from Home to Park (BFS):", bfs_path)

from collections import defaultdict

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)

    def add_edge(self, u, v):
        self.graph[u].append(v)

    def get_neighbors(self, u):
        return self.graph[u]

def dfs_shortest_path(graph, start, end, path=None):
    if path is None:
        path = []
    path = path + [start]
    if start == end:
        return path
    shortest = None
    for neighbor in graph.get_neighbors(start):
        if neighbor not in path:
            new_path = dfs_shortest_path(graph, neighbor, end, path)
            if new_path:
                if not shortest or len(new_path) < len(shortest):
                    shortest = new_path
    return shortest

def bfs_shortest_path(graph, start, end):
    queue = [(start, [start])]
    while queue:
        (vertex, path) = queue.pop(0)
        for neighbor in graph.get_neighbors(vertex):
            if neighbor not in path:
                if neighbor == end:
                    return path + [neighbor]
                else:
                    queue.append((neighbor, path + [neighbor]))

# Define the connections between locations in New York City
nyc_graph = Graph()
nyc_graph.add_edge("Times Square", "Central Park")
nyc_graph.add_edge("Times Square", "Empire State Building")
nyc_graph.add_edge("Central Park", "Empire State Building")
nyc_graph.add_edge("Central Park", "Statue of Liberty")
nyc_graph.add_edge("Statue of Liberty", "Empire State Building")

# Find the shortest path from Times Square to Central Park using DFS
dfs_path = dfs_shortest_path(nyc_graph, "Times Square", "Central Park")
print("Shortest path from Times Square to Central Park (DFS):", dfs_path)

# Find the shortest path from Times Square to Central Park using BFS
bfs_path = bfs_shortest_path(nyc_graph, "Times Square", "Central Park")
print("Shortest path from Times Square to Central Park (BFS):", bfs_path)

# Performance comparison
# DFS vs BFS: DFS may find a solution faster in some cases, but it may not always find the shortest path.
# BFS guarantees finding the shortest path, but it may take longer, especially in larger graphs.
# In this example, since the graph is relatively small, both DFS and BFS should find the shortest path efficiently.

# type your code here using DFS

from collections import defaultdict

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)

    def add_edge(self, u, v):
        self.graph[u].append(v)

    def get_neighbors(self, u):
        return self.graph[u]

def dfs_shortest_path(graph, start, end, path=None):
    if path is None:
        path = []
    path = path + [start]
    if start == end:
        return path
    shortest = None
    for neighbor in graph.get_neighbors(start):
        if neighbor not in path:
            new_path = dfs_shortest_path(graph, neighbor, end, path)
            if new_path:
                if not shortest or len(new_path) < len(shortest):
                    shortest = new_path
    return shortest

# Define the connections between locations in New York City
nyc_graph = Graph()
nyc_graph.add_edge("Times Square", "Central Park")
nyc_graph.add_edge("Times Square", "Empire State Building")
nyc_graph.add_edge("Central Park", "Empire State Building")
nyc_graph.add_edge("Central Park", "Statue of Liberty")
nyc_graph.add_edge("Statue of Liberty", "Empire State Building")

# Find the shortest path from Times Square to Central Park using DFS
dfs_path = dfs_shortest_path(nyc_graph, "Times Square", "Central Park")
print("Shortest path from Times Square to Central Park (DFS):", dfs_path)

# type your code here using BFS

from collections import defaultdict

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)

    def add_edge(self, u, v):
        self.graph[u].append(v)

    def get_neighbors(self, u):
        return self.graph[u]

def bfs_shortest_path(graph, start, end):
    queue = [(start, [start])]
    while queue:
        (vertex, path) = queue.pop(0)
        for neighbor in graph.get_neighbors(vertex):
            if neighbor not in path:
                if neighbor == end:
                    return path + [neighbor]
                else:
                    queue.append((neighbor, path + [neighbor]))

# Define the connections between locations in New York City
nyc_graph = Graph()
nyc_graph.add_edge("Times Square", "Central Park")
nyc_graph.add_edge("Times Square", "Empire State Building")
nyc_graph.add_edge("Central Park", "Empire State Building")
nyc_graph.add_edge("Central Park", "Statue of Liberty")
nyc_graph.add_edge("Statue of Liberty", "Empire State Building")

# Find the shortest path from Times Square to Central Park using BFS
bfs_path = bfs_shortest_path(nyc_graph, "Times Square", "Central Park")
print("Shortest path from Times Square to Central Park (BFS):", bfs_path)

"""#Type your evaluation about the performance of DFS and BFS

In this scenario of finding the shortest path between Times Square and Central Park in New York City, both DFS and BFS perform well due to the graph's small size. DFS may find a solution faster in some cases, but it doesn't guarantee the shortest path. On the other hand, BFS always finds the shortest path, albeit potentially taking longer, making it more reliable for larger or more complex graphs. Overall, while DFS may offer speed advantages, BFS ensures accuracy, making it preferable for guaranteeing the shortest path in most cases.

#### Conclusion

In conclusion, when solving transportation problems, both Depth-First Search (DFS) and Breadth-First Search (BFS) have their strengths. DFS can be quicker, especially when the shortest path is near the starting point. However, it doesn't guarantee the shortest path and may require extensive backtracking. Meanwhile, BFS ensures accuracy by systematically exploring paths layer by layer. Though it might take longer, it reliably finds the shortest path.Choosing between DFS and BFS depends on the problem's needs. If speed matters and an approximate solution is acceptable, DFS is suitable. But for precise and guaranteed optimal results, BFS is the better choice.
"""